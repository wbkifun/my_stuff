from __future__ import with_statement

import numpy as N
import pylab as P
import os


def parse_output(data_output_file):
    """
    This function parses the output of a fortran program generated by
    print *, 'x'
    print *, x
    etc.
    statments.

    input: data_output_file
    output: dictionary with keys corresponding to the variable
            names.
    """
    # parse the file
    with open(data_output_file, 'r') as fil:
        dict_ = {}
        # go through all the lines in the file
        for line in fil:
            ll = line.strip()
            if ll[0].isalpha():
                # if the first character in a line is a letter
                # it's the beginning of a new variable
                key = ll
                # make a new dict_ entry if it doesn't exist and
                # initialise as empty list
                if not dict_.has_key(key):
                    dict_[key] = []
                else:
                    # do nothing and continue to fill the list
                    pass
            else:
                # otherwise read the data
                ll = ll.split() # split at white space
                num = [float(el) for el in ll] # convert to float
                dict_[key].append(num) # append to the list

        # convert to numpy arrays
        for key in dict_:
            dict_[key] = N.array(dict_[key]).squeeze()
    return dict_

def compile_and_run(f_output_file, f_input_files, data_output_file):
    """
    Compiles a fortran program using
     - f_output_file as the executable produced
     - f_input_files as a list of the source code files (modules first)
     - data_output_file as the data file into which the output to
                        standard output of the fortran program
                        is piped
    """

    # compile the fortran program
    command1 = 'gfortran -o %s %s' %(f_output_file, ' '.join(f_input_files))
    exit_ = os.system(command1)
    # some primitve error checking
    if exit_!=0:
        raise(TypeError('\nCompliling with command "%s" failed' %command1))
    else:
        print 'Compiling ... ok'
    # run it
    command2 = './%s > %s' %(f_output_file,  data_output_file)
    exit_ = os.system(command2)
    # some primitve error checking
    if exit_!=0:
        raise(TypeError('\nRunning of fortran program with command "%s" failed.' %command2))
    else:
        print 'Running ... finished'
