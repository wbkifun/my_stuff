#------------------------------------------------------------------------------
# filename  : build.py
# author    : Ki-Hwan Kim  (kh.kim@kiaps.org)
# affilation: System Configuration Team, KIAPS
# update    : 2016.8.30    start
#             2016.9.5     f90 and c test OK
#             2016.9.6     cuda test OK
#             2016.9.7     opencl(ioc64) test OK
#
#
# description:
#   Check if sources are modified.
#   Generate parameters.h from YAML config files.
#   Compile sources
#   Link objects
#------------------------------------------------------------------------------

import numpy as np
import yaml
import subprocess as subp
import shutil
import os
from os.path import abspath, dirname, basename, join, exists, getmtime, getctime
from glob import glob

import sys 
from os.path import abspath, dirname, join
current_dpath = dirname(abspath(__file__))
sys.path.append(current_dpath)
from source_module import compile_using_f2py




param_template = '''
<COMMENT> Automatically generated by build.py
<COMMENT> Caution: Do Not Modify Manually

<CONTENT>
'''
def make_parameter_header(target_name, src_dict, code_type, target_dpath):
    kv_dict = dict()

    #
    # Search and load the yaml files
    #
    for src_yaml, blocks in src_dict.items():
        dirs = target_dpath.split('/')

        exist = False
        for i in range(len(dirs),1,-1):
            fpath = '/'.join(dirs[:i]) + '/' + src_yaml
            if exists(fpath): 
                exist = True
                break

        assert exist, '{} is not found in {} and upper directories'.format(src_yaml, target_dpath)
        with open(fpath, 'r') as f: param_dict = yaml.load(f)

        if len(blocks) == 0:
            kv_dict.update(param_dict)
        else:
            dd = {k2:v2 for k,v in param_dict.items() for k2,v2 in v.items()}
            kv_dict.update(dd)

    #
    # Make header content
    #
    lines = list()
    max_width = max([len(k) for k in kv_dict.keys()])

    for k in sorted(kv_dict.keys()):
        v = kv_dict[k]
        assert type(v) in [int,float], 'Error: parameter type is not int or float: {}={}'.format(k.upper(),v)

        if type(v) == float and code_type == 'f90':
            lines.append('#define {:<{mw}s} {}D0'.format(k.upper(), v, mw=max_width))
        else:
            lines.append('#define {:<{mw}s} {}'.format(k.upper(), v, mw=max_width))

    #
    # Make a header text from the template
    #
    template = param_template.replace('<CONTENT>', '\n'.join(lines))
    header = template.replace('<COMMENT>', '!' if code_type == 'f90' else '//')

    return header




def check_and_make_parameter_header(code_type, dpath):
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    if not exists(build_dpath): os.mkdir(build_dpath)

    for target_name in sorted(build_dict['param_header'].keys()):
        src_dict = build_dict['param_header'][target_name]

        header = make_parameter_header(target_name, src_dict, code_type, dpath)
        suffix = '.f90.h' if code_type == 'f90' else '.h'
        target_fpath = join(build_dpath, target_name+suffix)

        to_make = False
        if exists(target_fpath):
            with open(target_fpath, 'r') as f: 
                if header != f.read(): to_make = True
        else:
            to_make = True

        if to_make:
            print('{} is generated.'.format(target_fpath))
            with open(target_fpath, 'w') as f: f.write(header)
        else:
            print('{} is up to date.'.format(target_fpath))




def execute(cmd):
    ps = subp.Popen(cmd.split(), stdout=subp.PIPE, stderr=subp.PIPE)
    stdout, stderr = ps.communicate()
    sout = stdout.decode('utf-8')
    # Intel ioc64 OpenCL compiler
    if 'Unrecognized' in sout or 'Incorrect' in sout:
        print(sout)
    assert len(stderr) == 0, "{}\n{}".format(sout, stderr.decode('utf-8'))




def gather_dependency(dep_names, build_dict, name):
    if name not in build_dict['param_header'].keys():
        dep_names.append(name)

        if len(build_dict['depend'][name]) > 0:
            for name2 in build_dict['depend'][name]:
                gather_dependency(dep_names, build_dict, name2)




def compile(target_name, build_dict, code_type, dpath):
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    if not exists(build_dpath): os.mkdir(build_dpath)
    os.chdir(build_dpath)

    target_fpath = join(dpath, src_dir, target_name+'.'+code_type)
    env = build_dict[code_type]
    flags = '' if env['flags'] == None else env['flags']

    if target_name in build_dict['target'].keys():
        dep_names = list()
        for dep in build_dict['target'][target_name]:
            gather_dependency(dep_names, build_dict, dep)

        if code_type in ['f90', 'c']:
            opt_flags = '' if env['opt_flags'] == None else env['opt_flags']
            compile_using_f2py(target_fpath, \
                    env['compiler'], flags, opt_flags, dep_names)

        elif code_type == 'cu':
            if (dep_names) == 0:
                cmd = '{} -arch={} {} -I. -cubin {}'.format(env['compiler'], 
                        env['arch'], flags, target_fpath)
                print('[compile]', cmd.replace(target_fpath, basename(target_fpath)))
                execute(cmd)

            else:
                cmd = '{} -arch={} {} -I. --device-c {}'.format(env['compiler'], 
                        env['arch'], flags, target_fpath)
                print('[compile]', cmd.replace(target_fpath, basename(target_fpath)))
                execute(cmd)

                obj_fnames = ' '.join([name+'.o' for name in dep_names])
                cmd = '{} -arch={} {} --device-link {} {} -cubin -o {}'.format(
                        env['compiler'], env['arch'], flags, 
                        obj_fnames, target_name+'.o', target_name+'.cubin')
                print('[compile]', cmd)
                execute(cmd)

        elif code_type == 'cl':
            if (dep_names) == 0:
                cmd = '{} -device={} -cmd=compile -bo=-I.. {} -input={} -ir={}' \
                        .format(env['compiler'], env['device'], flags,
                        target_fpath, target_name+'.clbin')
                print('[compile]', cmd.replace(target_fpath, basename(target_fpath)))
                execute(cmd)

            else:
                cmd = '{} -device={} -cmd=compile -bo=-I.. {} -input={} -ir={}' \
                        .format(env['compiler'], env['device'], flags,
                        target_fpath, target_name+'.ir')
                print('[compile]', cmd.replace(target_fpath, basename(target_fpath)))
                execute(cmd)

                ir_fnames = ','.join([name+'.ir' for name in dep_names])
                cmd = '{} -device={} -cmd=link -binary={},{} -ir={}' \
                        .format(env['compiler'], env['device'],
                        ir_fnames, target_name+'.ir', target_name+'.clbin')
                print('[compile]', cmd)
                execute(cmd)

    else:
        if code_type == 'f90':
            compiler = {'gnu':'gfortran', 'intel':'ifort'}[env['compiler']]
            cmd = '{} -fPIC {} -I. -c {}'.format(compiler, flags, target_fpath)

        elif code_type == 'c':
            compiler = {'gnu':'gcc', 'intel':'icc'}[env['compiler']]
            cmd = '{} -fPIC {} -I. -c {}'.format(compiler, flags, target_fpath)

        elif code_type == 'cu':
            cmd = '{} -arch={} {} -I. --device-c {}'.format(env['compiler'], env['arch'], flags, target_fpath)

        elif code_type == 'cl':
            cmd = '{} -device={} -cmd=compile -bo=-I.. {} -input={} -ir={}' \
                    .format(env['compiler'], env['device'], flags,
                    target_fpath, target_name+'.ir')

        print('[compile]', cmd.replace(target_fpath, basename(target_fpath)))
        execute(cmd)




def check_and_build(code_type, dpath):
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    h_suffix = '.f90.h' if code_type == 'f90' else '.h'
    o_suffix = '.ir' if code_type == 'cl' else '.o'
    build_dpath = join(dpath, src_dir, 'build')

    #
    # Check dependencies and modification times
    #
    param_headers = list(build_dict['param_header'].keys())
    dep_stages = [param_headers, list()]
    dep_mtimes = {name:getmtime(join(build_dpath, name+h_suffix)) for name in param_headers}

    dep_dict = build_dict['depend'].copy()
    while len(dep_dict) > 0:
        pop_list = list()

        for name in sorted(dep_dict.keys()):
            dep_list = dep_dict[name]

            for stage in range(1,len(dep_stages)+1):
                accum_dep = [d for ds in dep_stages[:stage] for d in ds]

                if set(dep_list).issubset(set(accum_dep)):
                    if len(dep_stages) == stage: dep_stages.append([])
                    dep_stages[stage].append(name) 

                    obj_fpath = join(build_dpath, name+o_suffix)
                    dep_mtimes[name] = getmtime(obj_fpath) if exists(obj_fpath) else None
                    pop_list.append(name)
                    break

        for dep in pop_list: dep_dict.pop(dep)

    #print('dep_stages', dep_stages)
    #print('dep_mtimes', dep_mtimes)

    #
    # Compile dependent files
    #
    dep_dict = build_dict['depend']
    for deps in dep_stages[1:]:   # except stage 0 (parameter headers)
        #print('deps', deps)

        for dep_name in deps:
            #print('\ndep_name', dep_name)
            #print([d for d in dep_dict[dep_name]])
            mtime = dep_mtimes[dep_name]
            mtimes = [dep_mtimes[d] for d in dep_dict[dep_name]]

            dep_fpath = join(dpath, src_dir, dep_name+'.'+code_type)
            if mtime == None or \
               None in mtimes or \
               mtime < getmtime(dep_fpath) or \
               (len(mtimes) > 0 and mtime < max(mtimes)):
                compile(dep_name, build_dict, code_type, dpath)
            else:
                print('{} is up to date.'.format(join(build_dpath, dep_name+o_suffix)))

    #
    # Compile target files
    #
    lib_suffix = {'f90':'.f90.so', 'c':'.c.so', 'cu':'.cubin', 'cl':'.clbin'}[code_type]

    dep_dict = build_dict['target']
    for target in sorted(dep_dict.keys()):
        dep_list = dep_dict[target]

        dep_fpaths = list()
        for dep in dep_list:
            if dep in param_headers:
                dep_fpaths.append( join(build_dpath, dep+h_suffix) )
            else:
                dep_fpaths.append( join(build_dpath, dep+o_suffix) )
        mtimes = [getmtime(path) for path in dep_fpaths]

        lib_fpath = join(build_dpath, target+lib_suffix)
        src_fpath = join(dpath, src_dir, target+'.'+code_type)

        if (not exists(lib_fpath)) or \
           getmtime(lib_fpath) < getmtime(src_fpath) or \
           getmtime(lib_fpath) < max(mtimes):
            compile(target, build_dict, code_type, dpath)
        else:
            print('{} is up to date.'.format(lib_fpath))




def clean(code_type, dpath):
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')

    #
    # Remove shared libraries and signiture files
    #
    lib_suffixs = {'f90':['.f90.so','.f90.pyf'], \
                   'c'  :['.c.so'  ,'.c.pyf'  ], \
                   'cu' :['.cubin' ,'.o'      ], \
                   'cl' :['.clbin' ,'.ir'     ]}[code_type]
    for name in build_dict['target'].keys():
        for suffix in lib_suffixs:
            fpath = join(build_dpath, name+suffix)
            if os.path.exists(fpath): 
                print('rm {}'.format(fpath))
                os.remove(fpath)

    #
    # Remove object files
    #
    obj_suffixs = {'f90':['.o','.mod'], \
                   'c'  :['.o','.mod'], \
                   'cu' :['.o'       ], \
                   'cl' :['.ir'      ]}[code_type]
    for name in build_dict['depend'].keys():
        for suffix in obj_suffixs:
            fpath = join(build_dpath, name+suffix)
            if os.path.exists(fpath): 
                print('rm {}'.format(fpath))
                os.remove(fpath)

    #
    # Remove header files
    #
    h_suffix = {'f90':'.f90.h'}.get(code_type, '.h')
    for name in build_dict['param_header'].keys():
        fpath = join(build_dpath, name+h_suffix)
        if os.path.exists(fpath): 
            print('rm {}'.format(fpath))
            os.remove(fpath)
