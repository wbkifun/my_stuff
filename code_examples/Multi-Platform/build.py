#------------------------------------------------------------------------------
# filename  : build.py
# author    : Ki-Hwan Kim  (kh.kim@kiaps.org)
# affilation: System Configuration Team, KIAPS
# update    : 2016.8.30    start
#             2016.9.5     f90 and c test OK
#             2016.9.6     cuda test OK
#             2016.9.7     opencl(ioc64) test OK
#             2016.9.23    Add load_build_yaml() to check None values
#             2016.10.13   Join header and external files to one file
#
#
# description:
#   Check if sources are modified.
#   Generate parameters.h from YAML config files.
#   Compile sources
#   Link objects
#------------------------------------------------------------------------------

import numpy as np
import yaml
import subprocess as subp
import shutil
import os
from os.path import abspath, dirname, basename, join, exists, getmtime, getctime
from glob import glob

import sys 
from os.path import abspath, dirname, join
current_dpath = dirname(abspath(__file__))
sys.path.append(current_dpath)
from source_module import compile_using_f2py
from util.misc.load_yaml import load_yaml_dict




def load_build_yaml(dpath):
    fpath = join(dpath, 'build.yaml')
    assert exists(fpath), "Error: The 'build.yaml' file is not found in {}.".format(dpath)

    with open(fpath, 'r') as f: build_dict = yaml.load(f)
    ret = build_dict.copy()

    phs = build_dict['param_header']
    if phs is None:
        ret['param_header'] = dict()
    elif type(phs) is list:
        ret['param_header'] = {p:list() for p in phs}
    elif type(phs) is dict:
        ret['param_header'] = {p:list() if v==None else v for p, v in phs.items()}

    ds = build_dict['depend']
    if ds is None:
        ret['depend'] = dict()
    elif type(ds) is list:
        ret['depend'] = {d:list() for d in ds}
    elif type(ds) is dict:
        ret['depend'] = {d:list() if v==None else v for d, v in ds.items()}

    assert build_dict['target'] != None, "Error: The target section is None in the {}.".format.format(fpath)
    ts = build_dict['target']
    if type(ts) is list:
        ret['target'] = {t:list() for t in ts}
    elif type(ts) is dict:
        ret['target'] = {t:list() if v==None else v for t, v in ts.items()}

    return ret




param_template = '''
<COMMENT> Automatically generated by build.py
<COMMENT> Caution: Do Not Modify Manually

<CONTENT>
'''
def make_parameter_header(src_dict, code_type, target_dpath):
    kv_dict = dict()

    #
    # Search and load the yaml files
    #
    for src_yaml, blocks in src_dict.items():
        dirs = target_dpath.split('/')

        exist = False
        for i in range(len(dirs),1,-1):
            fpath = '/'.join(dirs[:i]) + '/' + src_yaml
            if exists(fpath): 
                exist = True
                break

        assert exist, '{} is not found in {} and upper directories'.format(src_yaml, target_dpath)
        #print('Generate header file from', fpath)
        param_dict = load_yaml_dict(fpath)

        if len(blocks) == 0:
            kv_dict.update(param_dict)
        else:
            for block in blocks:
                kv_dict.update(param_dict[block])


    #
    # Make header content
    #
    lines = list()
    max_width = max([len(k) for k in kv_dict.keys()])

    for k in sorted(kv_dict):
        v = kv_dict[k]
        assert type(v) in [int,float], 'Error: parameter type is not int or float: {}={}'.format(k.upper(),v)

        if type(v) == float and code_type == 'f90':
            if 'e' in str(v):
                lines.append('#define {:<{mw}s} ({})'.format(k.upper(), str(v).replace('e','D'), mw=max_width))
            else:
                lines.append('#define {:<{mw}s} ({}D0)'.format(k.upper(), v, mw=max_width))
        else:
            lines.append('#define {:<{mw}s} {}'.format(k.upper(), v, mw=max_width))

    #
    # Make a header text from the template
    #
    template = param_template.replace('<CONTENT>', '\n'.join(lines))
    header = template.replace('<COMMENT>', '!' if code_type == 'f90' else '//')

    return header




def check_and_make_parameter_header(code_type, dpath):
    build_dict = load_build_yaml(dpath)
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    if not exists(build_dpath): os.mkdir(build_dpath)

    for target_name in sorted(build_dict['param_header']):
        src_dict = build_dict['param_header'][target_name]

        header = make_parameter_header(src_dict, code_type, dpath)
        suffix = '.f90.h' if code_type == 'f90' else '.h'
        target_fpath = join(build_dpath, target_name+suffix)

        to_make = False
        if exists(target_fpath):
            with open(target_fpath, 'r') as f: 
                if header != f.read(): to_make = True
        else:
            to_make = True

        if to_make:
            print('{} is generated.'.format(target_fpath))
            with open(target_fpath, 'w') as f: f.write(header)
        else:
            print('{} is up to date.'.format(target_fpath))




def gather_dependency(target_name, build_dict, header_names, ext_names):
    if target_name in build_dict['target']:
        dep_list = build_dict['target'][target_name]

    elif target_name in build_dict['depend']:
        dep_list = build_dict['depend'][target_name]


    for name in dep_list:
        if name in build_dict['param_header']:
            if name not in header_names:
                header_names.append(name)
        else:
            if name not in ext_names:
                ext_names.append(name)
                gather_dependency(name, build_dict, header_names, ext_names)




def get_joined_code(target_name, build_dict, code_type, dpath):
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    src_dpath = join(dpath, src_dir)
    build_dpath = join(dpath, src_dir, 'build')

    assert target_name in build_dict['target'], "The target_name '{}' is not defined in the build.yaml".format(target_name)

    #
    # Gather dependent file names
    #
    header_names = list()
    ext_names = list()
    gather_dependency(target_name, build_dict, header_names, ext_names)

    #
    # Read header codes
    #
    h_suffix = '.f90.h' if code_type=='f90' else '.h'

    header_codes = list()
    for name in header_names[::-1]:
        fname = name + h_suffix
        build_fpath = join(build_dpath, fname)
        src_fpath = join(src_dpath, fname)

        if exists(build_fpath): 
            f = open(build_fpath, 'r')
        elif exists(src_fpath): 
            f = open(src_fpath, 'r')
        else:
            raise ValueError("The header file '{}' is not found.".format(fname))

        header_codes.append(f.read())

    #
    # Read external codes
    #
    ext_codes = list()
    for name in ext_names[::-1]:
        fname = name + '.' + code_type
        src_fpath = join(src_dpath, fname)

        with open(src_fpath, 'r') as f:
            ext_codes.append(f.read())

    #
    # Join codes to one
    #
    target_fpath = join(src_dpath, target_name+'.'+code_type)
    with open(target_fpath, 'r') as f: 
        target_code = f.read()

    joined_code = '\n\n\n\n'.join(header_codes + ext_codes + [target_code])

    return joined_code




def check_and_build(code_type, dpath, **kwargs):
    build_dict = load_build_yaml(dpath)
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')

    obj_suffix = {'f90':'f90.so', 'c':'c.so', 'cu':'cubin', 'cl':'clbin'}[code_type]
    env = build_dict[code_type]
    flags = '' if env['flags'] == None else env['flags']

    #
    # CUDA, OpenCL environment
    #
    if code_type == 'cu':
        from pycuda.compiler import compile

    elif code_type == 'cl':
        import pyopencl as cl

        cl_vendor_name = kwargs['opencl_vendor_name']
        cl_device_type = kwargs['opencl_device_type']

        platforms = cl.get_platforms()
        platform = [p for p in platforms if cl_vendor_name in p.vendor][0]
        devices = platform.get_devices()
        device = [d for d in devices if cl.device_type.to_string(d.type)==cl_device_type][0]
        context = cl.Context([device])

    #
    # Build
    #
    for target in sorted(build_dict['target']):
        joined_code = get_joined_code(target, build_dict, code_type, dpath)

        #
        # Check if revisionsed
        #
        obj_fpath = join(build_dpath, target+'.'+obj_suffix)
        joined_target_fpath = join(build_dpath, target+'.'+code_type)

        new_compile = True
        if exists(obj_fpath) and exists(joined_target_fpath): 
            with open(joined_target_fpath, 'r') as f:
                if joined_code == f.read(): 
                    new_compile = False

        if new_compile:
            with open(joined_target_fpath, 'w') as f:
                f.write(joined_code)

        #
        # Compile
        #
        if new_compile:
            if code_type in ['f90', 'c']:
                opt_flags = '' if env['opt_flags'] == None else env['opt_flags']
                compile_using_f2py(joined_target_fpath, env['compiler'], flags, opt_flags)

            elif code_type == 'cu':
                print('[compile] {} using the PyCUDA build'.format(basename(joined_target_fpath)) )
                cubin = compile(joined_code)
                with open(obj_fpath, 'wb') as f: 
                    f.write(cubin)


            elif code_type == 'cl':
                print('[compile] {} using the PyOpenCL build'.format(basename(joined_target_fpath)))

                prg = cl.Program(context, joined_code)
                prg.build(options=[])
                binary = prg.get_info(cl.program_info.BINARIES)[0]

                with open(obj_fpath, 'wb') as f:
                    f.write(binary)

        else:
            print('{} is up to date.'.format(joined_target_fpath))




def clean(code_type, dpath):
    build_dict = load_build_yaml(dpath)
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')

    #
    # Remove shared libraries and signiture files
    #
    lib_suffixs = {'f90':['.f90.so','.f90.pyf'], \
                   'c'  :['.c.so'  ,'.c.pyf'  ], \
                   'cu' :['.cubin' ,'.o'      ], \
                   'cl' :['.clbin' ,'.ir'     ]}[code_type]
    for name in build_dict['target']:
        for suffix in lib_suffixs:
            fpath = join(build_dpath, name+suffix)
            if os.path.exists(fpath): 
                print('rm {}'.format(fpath))
                os.remove(fpath)

    #
    # Remove object files
    #
    obj_suffixs = {'f90':['.o','.mod'], \
                   'c'  :['.o','.mod'], \
                   'cu' :['.o'       ], \
                   'cl' :['.ir'      ]}[code_type]
    for name in build_dict['depend']:
        for suffix in obj_suffixs:
            fpath = join(build_dpath, name+suffix)
            if os.path.exists(fpath): 
                print('rm {}'.format(fpath))
                os.remove(fpath)

    #
    # Remove header files
    #
    h_suffix = {'f90':'.f90.h'}.get(code_type, '.h')
    for name in build_dict['param_header']:
        fpath = join(build_dpath, name+h_suffix)
        if os.path.exists(fpath): 
            print('rm {}'.format(fpath))
            os.remove(fpath)

    #
    # Remove joined code files
    #
    joined_suffixs = {'f90':['.f90'], \
                      'c'  :['.c'  ], \
                      'cu' :['.cu' ], \
                      'cl' :['.cl' ]}[code_type]
    for name in build_dict['target']:
        for suffix in joined_suffixs:
            fpath = join(build_dpath, name+suffix)
            if os.path.exists(fpath): 
                print('rm {}'.format(fpath))
                os.remove(fpath)
