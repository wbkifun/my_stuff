import numpy as np
from numpy.testing import assert_equal as equal
from numpy.testing import assert_array_equal as a_equal
from numpy.testing import assert_array_almost_equal as aa_equal
from nose.tools import raises, ok_

import io
import sys
from os.path import abspath, dirname, join
current_dpath = dirname(abspath(__file__))
sys.path.append(current_dpath)




def capture(func):
    def wrapper(*args, **kwargs):
        capturer1 = io.StringIO()
        capturer2 = io.StringIO()
        old_stdout, sys.stdout = sys.stdout, capturer1
        old_stderr, sys.stderr = sys.stderr, capturer2

        ret = func(*args, **kwargs)

        sys.stdout, sys.stderr = old_stdout, old_stderr
        out = capturer1.getvalue().rstrip('\n')
        err = capturer2.getvalue().rstrip('\n')

        return ret, out, err

    return wrapper




def test_make_parameter_header_f90():
    '''
    make_parameter_header(): f90
    '''
    import yaml
    from build import make_parameter_header
    
    code_type = 'f90'

    dpath = join(current_dpath, 'src')
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)

    for target_name, src_dict in build_dict['param_header'].items():
        header = make_parameter_header(target_name, src_dict, code_type, dpath)

        if target_name == 'param1':
            expect = '''
! Automatically generated by build.py
! Caution: Do Not Modify Manually

#define KK  2
#define LLL 3.5D0
'''
            equal(header, expect)

        elif target_name == 'param2':
            expect = '''
! Automatically generated by build.py
! Caution: Do Not Modify Manually

#define MM 1.7D0
'''
            equal(header, expect)




def test_make_parameter_header_c():
    '''
    make_parameter_header(): c
    '''
    import yaml
    from build import make_parameter_header
    
    code_type = 'c'

    dpath = join(current_dpath, 'src')
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)

    for target_name, src_dict in build_dict['param_header'].items():
        header = make_parameter_header(target_name, src_dict, code_type, dpath)

        if target_name == 'param1':
            expect = '''
// Automatically generated by build.py
// Caution: Do Not Modify Manually

#define KK  2
#define LLL 3.5
'''
            equal(header, expect)

        elif target_name == 'param2':
            expect = '''
// Automatically generated by build.py
// Caution: Do Not Modify Manually

#define MM 1.7
'''
            equal(header, expect)




def test_check_and_make_parameter_header_f90():
    '''
    check_and_make_parameter_header(): f90
    '''
    import yaml
    import os
    import io
    import sys
    from build import check_and_make_parameter_header
    
    code_type = 'f90'
    suffix = '.f90.h' if code_type == 'f90' else '.h'

    dpath = join(current_dpath, 'src')
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)

    #
    # Remove previous generated files
    #
    for target_name, src_dict in build_dict['param_header'].items():
        f90_fpath = join(build_dpath, target_name+suffix)
        if os.path.exists(f90_fpath): os.remove(f90_fpath)

    #
    # Make and compile header file
    # verify stdout and file existence
    #
    ret, out, err = capture(check_and_make_parameter_header)(code_type, dpath)
    expect_list = list()
    for target_name in sorted(build_dict['param_header'].keys()):
        f90_fpath = join(build_dpath, target_name+suffix)
        expect_list.append('{} is generated.'.format(f90_fpath))
    equal(out, '\n'.join(expect_list))

    for target_name in sorted(build_dict['param_header'].keys()):
        f90_fpath = join(build_dpath, target_name+suffix)
        ok_( os.path.exists(f90_fpath) )

    #
    # verify stdout if revision
    #
    ret, out, err = capture(check_and_make_parameter_header)(code_type, dpath)
    expect_list = list()
    for target_name in sorted(build_dict['param_header'].keys()):
        f90_fpath = join(build_dpath, target_name+suffix)
        expect_list.append('{} is up to date.'.format(f90_fpath))
    equal(out, '\n'.join(expect_list))




def test_check_and_build_f90():
    '''
    check_and_build(): f90
    '''
    import yaml
    import os
    from build import check_and_make_parameter_header, check_and_build, clean
    from source_module import get_module_from_file

    code_type = 'f90'

    dpath = join(current_dpath, 'src')
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)

    #
    # Remove previous generated files
    #
    ret, out, err = capture(clean)(code_type, dpath)
    equal( len(os.listdir(build_dpath)), 0 )

    #
    # Make and compile header file
    # verify stdout and file existence
    #
    ret, out, err = capture(check_and_make_parameter_header)(code_type, dpath)
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] gfortran -fPIC -cpp -I. -c amb_ext2.f90
[compile] gfortran -fPIC -cpp -I. -c apb_ext.f90
[compile] gfortran -fPIC -cpp -I. -c amb_ext1.f90
[compile] f2py -c --fcompiler=gnu95 --f90flags="-cpp" --opt="-O3" -I. amb.f90.pyf amb_ext1.o amb_ext2.o amb.f90
[compile] f2py -c --fcompiler=gnu95 --f90flags="-cpp" --opt="-O3" -I. apb.f90.pyf apb_ext.o apb.f90
'''
    equal('\n'+out+'\n', expect)

    mod_apb = get_module_from_file(build_dpath, 'apb', code_type)
    mod_amb = get_module_from_file(build_dpath, 'amb', code_type)


    #
    # setup
    #
    nx = 1000000
    a = np.random.rand(nx)
    b = np.random.rand(nx)
    c = np.random.rand(nx)
    c2 = c.copy()

    with open(join(dpath, 'apb.yaml'), 'r') as f: apb_dict = yaml.load(f)
    with open(join(dpath, 'amb.yaml'), 'r') as f: amb_dict = yaml.load(f)
    kk = apb_dict['kk']
    lll = apb_dict['lll']
    mm = amb_dict['section']['mm']

    ref = kk*a + lll*b + mm*c


    #
    # verify results
    #
    mod_apb.apb(nx, a, b, c)
    aa_equal(ref, c, 14)

    mod_amb.amb(nx, a, b, c2)
    aa_equal(ref, c2, 14)


    #
    # verify stdout if revision
    #
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
./f90/build/amb_ext2.o is up to date.
./f90/build/apb_ext.o is up to date.
./f90/build/amb_ext1.o is up to date.
./f90/build/amb.f90.so is up to date.
./f90/build/apb.f90.so is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)


    #
    # verify stdout if partial revision
    #
    os.remove(join(build_dpath, 'amb_ext2.o'))
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] gfortran -fPIC -cpp -I. -c amb_ext2.f90
./f90/build/apb_ext.o is up to date.
[compile] gfortran -fPIC -cpp -I. -c amb_ext1.f90
[compile] f2py -c --fcompiler=gnu95 --f90flags="-cpp" --opt="-O3" -I. amb.f90.pyf amb_ext1.o amb_ext2.o amb.f90
./f90/build/apb.f90.so is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)




def test_check_and_build_c():
    '''
    check_and_build(): c
    '''
    import yaml
    import os
    from build import check_and_make_parameter_header, check_and_build, clean
    from source_module import get_module_from_file

    code_type = 'c'

    dpath = join(current_dpath, 'src')
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)

    #
    # Remove previous generated files
    #
    ret, out, err = capture(clean)(code_type, dpath)
    equal( len(os.listdir(build_dpath)), 0 )

    #
    # Make and compile header file
    # verify stdout and file existence
    #
    ret, out, err = capture(check_and_make_parameter_header)(code_type, dpath)
    #check_and_build(code_type, dpath)
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] gcc -fPIC  -I. -c amb_ext2.c
[compile] gcc -fPIC  -I. -c apb_ext.c
[compile] gcc -fPIC  -I. -c amb_ext1.c
[compile] f2py -c --compiler=unix --f90flags="" --opt="-O3" -I. amb.c.pyf amb_ext1.o amb_ext2.o amb.c
[compile] f2py -c --compiler=unix --f90flags="" --opt="-O3" -I. apb.c.pyf apb_ext.o apb.c
'''
    equal('\n'+out+'\n', expect)

    mod_apb = get_module_from_file(build_dpath, 'apb', code_type)
    mod_amb = get_module_from_file(build_dpath, 'amb', code_type)


    #
    # setup
    #
    nx = 1000000
    a = np.random.rand(nx)
    b = np.random.rand(nx)
    c = np.random.rand(nx)
    c2 = c.copy()

    with open(join(dpath, 'apb.yaml'), 'r') as f: apb_dict = yaml.load(f)
    with open(join(dpath, 'amb.yaml'), 'r') as f: amb_dict = yaml.load(f)
    kk = apb_dict['kk']
    lll = apb_dict['lll']
    mm = amb_dict['section']['mm']

    ref = kk*a + lll*b + mm*c


    #
    # verify results
    #
    mod_apb.apb(nx, a, b, c)
    aa_equal(ref, c, 14)

    mod_amb.amb(nx, a, b, c2)
    aa_equal(ref, c2, 14)


    #
    # verify stdout if revision
    #
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
./c/build/amb_ext2.o is up to date.
./c/build/apb_ext.o is up to date.
./c/build/amb_ext1.o is up to date.
./c/build/amb.c.so is up to date.
./c/build/apb.c.so is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)


    #
    # verify stdout if partial revision
    #
    os.remove(join(build_dpath, 'amb_ext2.o'))
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] gcc -fPIC  -I. -c amb_ext2.c
./c/build/apb_ext.o is up to date.
[compile] gcc -fPIC  -I. -c amb_ext1.c
[compile] f2py -c --compiler=unix --f90flags="" --opt="-O3" -I. amb.c.pyf amb_ext1.o amb_ext2.o amb.c
./c/build/apb.c.so is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)




def test_check_and_build_cu():
    '''
    check_and_build(): cuda
    '''
    import yaml
    import os
    import pycuda.driver as cuda
    import atexit
    from build import check_and_make_parameter_header, check_and_build, clean

    code_type = 'cu'

    dpath = join(current_dpath, 'src')
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)

    #
    # Remove previous generated files
    #
    ret, out, err = capture(clean)(code_type, dpath)
    equal( len(os.listdir(build_dpath)), 0 )

    #
    # Make and compile header file
    # verify stdout and file existence
    #
    ret, out, err = capture(check_and_make_parameter_header)(code_type, dpath)
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] nvcc -arch=sm_20  -I. --device-c amb_ext2.cu
[compile] nvcc -arch=sm_20  -I. --device-c apb_ext.cu
[compile] nvcc -arch=sm_20  -I. --device-c amb_ext1.cu
[compile] nvcc -arch=sm_20  -I. --device-c amb.cu
[compile] nvcc -arch=sm_20  --device-link amb_ext1.o amb_ext2.o amb.o -cubin -o amb.cubin
[compile] nvcc -arch=sm_20  -I. --device-c apb.cu
[compile] nvcc -arch=sm_20  --device-link apb_ext.o apb.o -cubin -o apb.cubin
'''
    equal('\n'+out+'\n', expect)

    #
    # PyCUDA environment
    # Load modules
    #
    cuda.init()
    device = cuda.Device(0)
    context = device.make_context()
    atexit.register(context.pop)

    lib_apb = cuda.module_from_file( join(build_dpath, 'apb.cubin') )
    lib_amb = cuda.module_from_file( join(build_dpath, 'amb.cubin') )

    apb = lib_apb.get_function('apb')
    amb = lib_amb.get_function('amb')


    #
    # setup
    #
    nx = 1000000
    a = np.random.rand(nx)
    b = np.random.rand(nx)
    c = np.random.rand(nx)
    c2 = c.copy()

    a_dev = cuda.to_device(a)
    b_dev = cuda.to_device(b)
    c_dev = cuda.to_device(c)
    c2_dev = cuda.to_device(c2)

    with open(join(dpath, 'apb.yaml'), 'r') as f: apb_dict = yaml.load(f)
    with open(join(dpath, 'amb.yaml'), 'r') as f: amb_dict = yaml.load(f)
    kk = apb_dict['kk']
    lll = apb_dict['lll']
    mm = amb_dict['section']['mm']

    ref = kk*a + lll*b + mm*c


    #
    # verify results
    #
    apb(np.int32(0), np.int32(nx), a_dev, b_dev, c_dev, block=(512,1,1), grid=(nx//512+1,1))
    cuda.memcpy_dtoh(c, c_dev)
    aa_equal(ref, c, 14)

    amb(np.int32(0), np.int32(nx), a_dev, b_dev, c2_dev, block=(512,1,1), grid=(nx//512+1,1))
    cuda.memcpy_dtoh(c2, c2_dev)
    aa_equal(ref, c2, 14)


    #
    # verify stdout if revision
    #
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
./cuda/build/amb_ext2.o is up to date.
./cuda/build/apb_ext.o is up to date.
./cuda/build/amb_ext1.o is up to date.
./cuda/build/amb.cubin is up to date.
./cuda/build/apb.cubin is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)


    #
    # verify stdout if partial revision
    #
    os.remove(join(build_dpath, 'amb_ext2.o'))
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] nvcc -arch=sm_20  -I. --device-c amb_ext2.cu
./cuda/build/apb_ext.o is up to date.
[compile] nvcc -arch=sm_20  -I. --device-c amb_ext1.cu
[compile] nvcc -arch=sm_20  -I. --device-c amb.cu
[compile] nvcc -arch=sm_20  --device-link amb_ext1.o amb_ext2.o amb.o -cubin -o amb.cubin
./cuda/build/apb.cubin is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)




def test_check_and_build_cl():
    '''
    check_and_build(): opencl
    '''
    import yaml
    import os
    import pyopencl as cl
    from build import check_and_make_parameter_header, check_and_build, clean

    code_type = 'cl'

    dpath = join(current_dpath, 'src')
    src_dir = {'f90':'f90', 'c':'c', 'cu':'cuda', 'cl':'opencl'}[code_type]
    build_dpath = join(dpath, src_dir, 'build')
    with open(join(dpath, 'build.yaml'), 'r') as f: build_dict = yaml.load(f)

    #
    # Remove previous generated files
    #
    ret, out, err = capture(clean)(code_type, dpath)
    equal( len(os.listdir(build_dpath)), 0 )

    #
    # Make and compile header file
    # verify stdout and file existence
    #
    ret, out, err = capture(check_and_make_parameter_header)(code_type, dpath)
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=amb_ext2.cl -ir=amb_ext2.ir
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=apb_ext.cl -ir=apb_ext.ir
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=amb_ext1.cl -ir=amb_ext1.ir
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=amb.cl -ir=amb.ir
[compile] ioc64 -device=cpu -cmd=link -binary=amb_ext1.ir,amb_ext2.ir,amb.ir -ir=amb.clbin
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=apb.cl -ir=apb.ir
[compile] ioc64 -device=cpu -cmd=link -binary=apb_ext.ir,apb.ir -ir=apb.clbin
'''
    equal('\n'+out+'\n', expect)

    #
    # PyOpenCL environment
    # Load modules
    #
    platforms = cl.get_platforms()
    platform = [p for p in platforms if 'Intel' in p.vendor][0]
    devices = platform.get_devices()
    device = [d for d in devices if cl.device_type.to_string(d.type)=='CPU'][0]

    context = cl.Context([device])
    queue = cl.CommandQueue(context, device)

    with open(join(build_dpath,'apb.clbin'), 'rb') as f:
        prg = cl.Program(context, [device], [f.read()])
        lib_apb, out, err = capture(prg.build)()
    with open(join(build_dpath,'amb.clbin'), 'rb') as f:
        prg = cl.Program(context, [device], [f.read()])
        lib_amb, out, err = capture(prg.build)()


    #
    # setup
    #
    nx = 1000000
    a = np.random.rand(nx)
    b = np.random.rand(nx)
    c = np.random.rand(nx)
    c2 = c.copy()

    mf = cl.mem_flags
    nx_cl = np.int32(nx)
    a_dev = cl.Buffer(context, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=a)
    b_dev = cl.Buffer(context, mf.READ_WRITE | mf.COPY_HOST_PTR, hostbuf=b)
    c_dev = cl.Buffer(context, mf.READ_WRITE | mf.COPY_HOST_PTR, hostbuf=c)
    c2_dev = cl.Buffer(context, mf.READ_WRITE | mf.COPY_HOST_PTR, hostbuf=c2)

    with open(join(dpath, 'apb.yaml'), 'r') as f: apb_dict = yaml.load(f)
    with open(join(dpath, 'amb.yaml'), 'r') as f: amb_dict = yaml.load(f)
    kk = apb_dict['kk']
    lll = apb_dict['lll']
    mm = amb_dict['section']['mm']

    ref = kk*a + lll*b + mm*c


    #
    # verify results
    #
    lib_apb.apb(queue, (nx,), None, nx_cl, a_dev, b_dev, c_dev)
    cl.enqueue_copy(queue, c, c_dev)
    aa_equal(ref, c, 14)

    lib_amb.amb(queue, (nx,), None, nx_cl, a_dev, b_dev, c2_dev)
    cl.enqueue_copy(queue, c2, c2_dev)
    aa_equal(ref, c2, 14)


    #
    # verify stdout if revision
    #
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
./opencl/build/amb_ext2.ir is up to date.
./opencl/build/apb_ext.ir is up to date.
./opencl/build/amb_ext1.ir is up to date.
./opencl/build/amb.clbin is up to date.
./opencl/build/apb.clbin is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)


    #
    # verify stdout if partial revision
    #
    os.remove(join(build_dpath, 'amb_ext2.ir'))
    ret, out, err = capture(check_and_build)(code_type, dpath)
    expect = '''
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=amb_ext2.cl -ir=amb_ext2.ir
./opencl/build/apb_ext.ir is up to date.
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=amb_ext1.cl -ir=amb_ext1.ir
[compile] ioc64 -device=cpu -cmd=compile -bo=-I..  -input=amb.cl -ir=amb.ir
[compile] ioc64 -device=cpu -cmd=link -binary=amb_ext1.ir,amb_ext2.ir,amb.ir -ir=amb.clbin
./opencl/build/apb.clbin is up to date.
'''
    equal('\n'+out.replace(dpath,'.')+'\n', expect)
