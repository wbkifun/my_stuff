#------------------------------------------------------------------------------
# filename  : sphere.py
# author    : Ki-Hwan Kim  (kh.kim@kiaps.org)
# affilation: KIAPS (Korea Institute of Atmospheric Prediction Systems)
# update    : 2015.12.17    copy from pygecore_2014.6.23
#             2015.12.18    add distance3, angle3 for Delaunay flipping
#             2016.8.2      range(len(xyzs)) -> list( range(len(xyzs)) )
#             2016.8.25     fix the relative import path
#
#
# Description: 
#   Area of a polygon on the sphere
#------------------------------------------------------------------------------

import numpy as np
from math import fsum, sqrt, tan, atan, acos

import sys
from os.path import abspath, dirname
current_dpath = dirname(abspath(__file__))
sys.path.extend([current_dpath,dirname(current_dpath)])
from misc.compare_float import feq, flt, fgt
from duplicate import remove_duplicates




def angle(xyz1, xyz2):
    '''
    angle <AOB
    '''
    cross = np.linalg.norm( np.cross(xyz1, xyz2) ) 
    dot = np.dot(xyz1, xyz2)

    return np.arctan2(cross,dot)




def distance3(xyz1, xyz2):
    x1, y1, z1 = xyz1
    x2, y2, z2 = xyz2

    return sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)




def angle3(xyz1, xyz2, xyz3):
    '''
    angle <ABC
    '''
    d12 = distance3(xyz1, xyz2)
    d23 = distance3(xyz2, xyz3)
    d13 = distance3(xyz1, xyz3)

    return acos( (d12**2 + d23**2 - d13**2)/(2*d12*d23) )




def area_triangle(xyz1, xyz2, xyz3):
    '''
    Area of spherical triangle using Girard theorem
    '''
    a = angle(xyz1, xyz2)
    b = angle(xyz2, xyz3)
    c = angle(xyz3, xyz1)
    s = 0.5*(a+b+c)

    inval = tan(0.5*s) * tan(0.5*(s-a)) * tan(0.5*(s-b)) * tan(0.5*(s-c))
    area = 0 if inval < 0 else 4*atan( sqrt(inval) ) 

    return area




def area_polygon(xyzs):
    '''
    Area from divided spherical triangles
    '''
    area_triangles = list()
    xyz1 = xyzs[0]
    for xyz2, xyz3 in zip(xyzs[1:-1], xyzs[2:]):
        area_tri = area_triangle(xyz1, xyz2, xyz3)
        area_triangles.append(area_tri)

    area = fsum(area_triangles)

    return area




def normal_vector(xyz1, xyz2, normalize=False):
    nvec = np.cross(xyz1, xyz2)
    
    if normalize:
        return nvec/np.linalg.norm(nvec)
    else:
        return nvec




def plane_origin(xyz1, xyz2):
    '''
    return plane parameters (a,b,c) from two points on the sphere
    '''

    x1, y1, z1 = xyz1
    x2, y2, z2 = xyz2
    a, b, c = y1*z2-z1*y2, z1*x2-x1*z2, x1*y2-y1*x2

    return (a, b, c)




def sort_ccw_idxs(xyzs):
    '''
    sort in counter-clockwise
    The points should be not duplicated.
    '''

    candidate_idxs = list( range(len(xyzs)) )
    sorted_idxs = [candidate_idxs.pop(0)]

    while True:
        xyz1 = xyzs[sorted_idxs[-1]]
        idx2 = candidate_idxs[-1]

        for idx3 in candidate_idxs[:-1]:
            xyz2 = xyzs[idx2]
            xyz3 = xyzs[idx3]
            lr = plane12_pt3(xyz1, xyz2, xyz3)
            
            if lr == 'right':
                idx2 = idx3

            elif lr == 'straight':
                if arc12_pt3(xyz1, xyz2, xyz3) == 'between':
                    idx2 = idx3

        candidate_idxs.remove(idx2)
        sorted_idxs.append(idx2)

        if len(candidate_idxs) == 0:
            break

    return sorted_idxs




def arc12_pt3(xyz1, xyz2, xyz3):
    '''
    Three points should be on same circle.
    '''

    vec1 = x1, y1, z1 = xyz1
    vec2 = x2, y2, z2 = xyz2
    vec3 = x3, y3, z3 = xyz3

    unit_nvec = normal_vector(vec1, vec2, normalize=True)
    cp1 = np.dot(unit_nvec, np.cross(vec1, vec3))
    cp2 = np.dot(unit_nvec, np.cross(vec2, vec3))

    if feq(cp1,0):
        if feq(cp2,0):
            raise ValueError("cp1 and cp2 are both zero")
        elif flt(cp2,0):
            return 'pt1'
        elif fgt(cp2,0):
            return 'out'

    elif flt(cp1,0):
        return 'out'

    elif fgt(cp1,0):
        if feq(cp2,0):
            return 'pt2'
        elif flt(cp2,0):
            return 'between'
        elif fgt(cp2,0):
            return 'out'




def plane12_pt3(xyz1, xyz2, xyz3):
    '''
    plane generated by xyz1 and xyz2
    left if xyz3 is in normal vector direction
    '''

    plane = plane_origin(xyz1, xyz2)
    #nvec = normal_vector(xyz1, xyz2)
    #print np.dot(plane,nvec)       # > 0 

    val = np.dot(plane, xyz3)

    if feq(val,0):
        return 'straight'
    elif flt(val,0):
        return 'right'
    elif fgt(val,0):
        return 'left'




def pt_in_polygon(polygon_xyzs, xyz3):
    '''
    The polygon vertices should be sorted in counter-clockwise.
    '''
    xyzs = polygon_xyzs

    lr_set = set()
    for xyz1, xyz2 in zip(xyzs, xyzs[1:]+xyzs[:1]):
        lr = plane12_pt3(xyz1, xyz2, xyz3)
        lr_set.add(lr)

    if 'right' in lr_set:
        return 'out'
    elif 'straight' in lr_set:
        return 'border'
    elif ['left'] == list(lr_set): 
        return 'in'
    else:
        raise ValueError("lr_set={}".format(lr_set))




def intersect_two_greatcircles(abc1, abc2):
    '''
    Two intersection points of two planes and a sphere
    Input are plane parameters.
    '''

    a1, b1, c1 = abc1
    a2, b2, c2 = abc2

    if feq(a1,a2) and feq(b1,b2) and feq(c1,c2):
        return None, None

    elif feq(a1,0) and feq(a2,0):
        s1, s2 = [(1,0,0), (-1,0,0)]

    elif feq(b1,0) and feq(b2,0):
        s1, s2 = [(0,1,0), (0,-1,0)]

    elif feq(c1,0) and feq(c2,0):
        s1, s2 = [(0,0,1), (0,0,-1)]

    elif feq(c2*b1, c1*b2):
        A = a2*c1-a1*c2
        B = a2*b1-a1*b2
        denom = A*A + B*B

        #if feq(denom,0):
        if denom == 0:
            return None, None
        else:
            Z = 1/np.sqrt(denom)
            s1 = (0, A*Z, -B*Z)
            s2 = (0, -A*Z, B*Z)

    else:
        A = b2*c1-b1*c2
        B = c2*a1-c1*a2
        C = b2*a1-b1*a2
        denom = A*A + B*B + C*C

        #if feq(denom,0):
        if denom == 0:
            return None, None
        else:
            Z = 1/np.sqrt(denom)
            s1 = (A*Z, B*Z, -C*Z)
            s2 = (-A*Z, -B*Z, C*Z)

    return s1, s2




def intersect_two_arcs(xyz1, xyz2, xyz3, xyz4):
    '''
    We assume two arcs are part of greatcircles.
    The arc should be smaller than half greatcircle.
    '''

    #------------------------------------------
    # two intersection points
    #------------------------------------------
    plane1 = plane_origin(xyz1, xyz2)
    plane2 = plane_origin(xyz3, xyz4)

    s1, s2 = intersect_two_greatcircles(plane1, plane2)
    if s1 == None and s2 == None:
        return None


    #------------------------------------------
    # select one solution
    #------------------------------------------
    p12_s1 = arc12_pt3(xyz1, xyz2, s1)
    p34_s1 = arc12_pt3(xyz3, xyz4, s1)
    p12_s2 = arc12_pt3(xyz1, xyz2, s2)
    p34_s2 = arc12_pt3(xyz3, xyz4, s2)

    if p12_s1=='out' or p34_s1=='out': check_s1 = None
    elif p12_s1 == 'pt1': check_s1 = 'pt1'
    elif p12_s1 == 'pt2': check_s1 = 'pt2'
    elif p34_s1 == 'pt1': check_s1 = 'pt3'
    elif p34_s1 == 'pt2': check_s1 = 'pt4'
    else: check_s1 = s1

    if p12_s2=='out' or p34_s2=='out': check_s2 = None
    elif p12_s2 == 'pt1': check_s2 = 'pt1'
    elif p12_s2 == 'pt2': check_s2 = 'pt2'
    elif p34_s2 == 'pt1': check_s2 = 'pt3'
    elif p34_s2 == 'pt2': check_s2 = 'pt4'
    else: check_s2 = s2

    '''
    print ''
    print np.rad2deg(xyz2latlon(*s1))
    print np.rad2deg(xyz2latlon(*s2))
    print 'p12_s1, p34_s1', p12_s1, p34_s1
    print 'p12_s2, p34_s2', p12_s2, p34_s2
    print 'check_s1=%s, check_s2=%s' % (check_s1,check_s2)
    '''


    if check_s1 != None and check_s2 != None:
        raise ValueError("check_s1 and check_s2 are neither None.\ncheck_s1={}, check_s2={}\np12_s1={}, p34_s1={}, p12_s2={}, p34_s2={}".format(check_s1,check_s2,p12_s1,p34_s1,p12_s2,p34_s2))

    elif check_s1 == None and check_s2 == None:
        return None

    elif check_s1 == None:
        return check_s2

    elif check_s2 == None:
        return check_s1




def intersect_two_polygons(polygon_xyzs1, polygon_xyzs2):
    '''
    The points of polygons should be sorted in counter-clockwise
    '''
    xyzs1 = polygon_xyzs1
    xyzs2 = polygon_xyzs2


    #-----------------------------------------------------------
    # Check in/out
    #-----------------------------------------------------------
    poly1_inout = list()
    for xyz in xyzs1:
        inout = pt_in_polygon(xyzs2, xyz)
        poly1_inout.append(inout)

    poly2_inout = list()
    for xyz in xyzs2:
        inout = pt_in_polygon(xyzs1, xyz)
        poly2_inout.append(inout)


    #-----------------------------------------------------------
    # Not overlap and inclusion
    #-----------------------------------------------------------
    if 'out' not in poly1_inout and 'in' not in poly2_inout:
        return xyzs1

    elif 'in' not in poly1_inout and 'out' not in poly2_inout:
        return xyzs2


    #-----------------------------------------------------------
    # Partially overlapped
    #-----------------------------------------------------------
    vertices = list()

    #---------------------------------
    # inner and border points
    #---------------------------------
    for seq, io1 in enumerate(poly1_inout):
        if io1 != 'out':
            vertices.append( xyzs1[seq] )

    for seq, io2 in enumerate(poly2_inout):
        if io2 != 'out':
            vertices.append( xyzs2[seq] )


    #---------------------------------
    # intersection points
    #---------------------------------
    for xyz1, xyz2 in zip(xyzs1, xyzs1[1:]+xyzs1[:1]):
        for xyz3, xyz4 in zip(xyzs2, xyzs2[1:]+xyzs2[:1]):
            ret = intersect_two_arcs(xyz1, xyz2, xyz3, xyz4)

            if ret != None and 'pt' not in ret:
                vertices.append(ret)


    #---------------------------------
    # remove duplicates
    #---------------------------------
    unique_xyzs = remove_duplicates(vertices)

    if len(vertices) < 3:
        return None


    #---------------------------------
    # sorting in counter-clockwise
    #---------------------------------
    sort_idxs = sort_ccw_idxs(unique_xyzs)
    sorted_xyzs = [unique_xyzs[idx] for idx in sort_idxs]


    return sorted_xyzs
